import{_ as s,c as a,o as n,a as l}from"./app.59ae87fb.js";const A=JSON.parse('{"title":"TypeScript readonly","description":"","frontmatter":{},"headers":[{"level":2,"title":"Readonly vs. const","slug":"readonly-vs-const","link":"#readonly-vs-const","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"relativePath":"class/typescript-readonly.md"}'),o={name:"class/typescript-readonly.md"},p=l(`<h1 id="typescript-readonly" tabindex="-1">TypeScript readonly <a class="header-anchor" href="#typescript-readonly" aria-hidden="true">#</a></h1><p>摘要：在本教程中，你将学习如何使用 TypeScript 的 readonly 访问修改器，将类属性标记为不可变的属性。</p><p>TypeScript 提供了 readonly 修改器，<strong>允许你标记一个类的属性为不可变的。只有在以下两个地方之一才能对只读属性进行赋值：</strong></p><ul><li><strong>在属性声明中。</strong></li><li><strong>在同一个类的构造函数中。</strong></li></ul><p>要把一个属性标记为不可变的，你可以使用 readonly 关键字。下面显示了如何在 Person 类中声明一个只读属性：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">readonly</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">birthDate</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Date</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">birthDate</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Date</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">birthDate</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">birthDate</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>在这个例子中，<code>birthDate</code> 属性是一个只读属性，在 <code>Person</code> 类的构造函数中被初始化。</p><p>下面的尝试重新分配 <code>birthDate</code> 属性会导致错误：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> person </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Date</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1990</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">12</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">25</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">birthDate </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Date</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1991</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">12</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">25</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// Compile error</span></span>
<span class="line"></span></code></pre></div><p>像其他访问修饰符一样，你可以像这样把 readonly 的声明和初始化合并到构造函数中：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">readonly</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">birthDate</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Date</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">birthDate</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">birthDate</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="readonly-vs-const" tabindex="-1">Readonly vs. const <a class="header-anchor" href="#readonly-vs-const" aria-hidden="true">#</a></h2><p>下面显示了 readonly 和 const 之间的区别：</p><table><thead><tr><th>-</th><th>readonly</th><th>const</th></tr></thead><tbody><tr><td>用于</td><td>类型属性</td><td>变量</td></tr><tr><td>初始化</td><td>在声明中或者同一个类的构造函数中</td><td>在声明中</td></tr></tbody></table><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><ul><li>使用只读访问修饰符来标记一个类属性为不可变的。</li><li>一个只读的属性必须作为声明的一部分或在同一个类的构造函数中被初始化。</li></ul>`,16),e=[p];function t(r,c,y,D,C,i){return n(),a("div",null,e)}const d=s(o,[["render",t]]);export{A as __pageData,d as default};
